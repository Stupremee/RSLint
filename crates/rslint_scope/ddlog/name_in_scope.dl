import vec
import ast
import utils
import group
import inputs
import scopes

typedef NameOrigin =
    AutoGlobal
    | Imported
    | UserDefined { scope: ScopeId }

typedef NameInScope = NameInScope {
    file: FileId,
    name: Name,
    scope: ScopeId,
    span: Option<Span>,
    declared_in: AnyId,
    implicit: bool,
    is_arg: bool,
    origin: NameOrigin,
}

// The `NameInScope` relation gives every name/symbol/ident that's defined for any given scope.
// Names are walked down children scopes, meaning all children have access to the variables of
// their parent scope(s)
//
// ```
// // 'a defines the `foo` symbol
// 'a: { foo }
//  │
//  │ // 'b defines the `bar` symbol and inherits
//  │ // the `foo` symbol
//  └-'b: { foo, bar }
// ```
//
relation NameInScope[NameInScope]

// An index that returns all variables avaliable in a given scope
index Index_VariablesForScope(file: FileId, scope: ScopeId)
    on NameInScope[NameInScope { .file = file, .scope = scope }]

// An index that returns all variables by the given name in the given scope
index Index_VariableInScope(file: FileId, scope: ScopeId, variable: Name)
    on NameInScope[NameInScope { .file = file, .name = variable, .scope = scope }]

// Add implicit globals to every scope
NameInScope(file, name, scope, None, AnyIdGlobal { global }, true, false, AutoGlobal) :-
    ImplicitGlobal(global, file, name, _),
    EveryScope(scope, file).

// Import declarations
//
// ```js
// // Scope: { Foo, Bar, .. }
// import { Foo, Bar } from "./somewhere.js";
// // Scope: { Foo, Bar, .. }
// ```
NameInScope(file, name, scope, Some { span }, AnyIdImport { id }, false, false, Imported) :-
    ImportDecl(id, file, clause),
    EveryScope(scope, file),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var free_var = FlatMap(clause.free_variables()),
    Spanned { var name, var span } = free_var.

// Class declarations
//
// Class declarations create a new scope when they're declared,
// so we add the class's name within that scope
//
// ```js
// // Scope: { ... }
// class Baz { }
// // Scope: { Baz, ... }
// ```
//
NameInScope(
    file,
    name,
    scope,
    Some { span },
    AnyIdClass { class },
    false,
    false,
    UserDefined { scope },
) :-
    Class(class, file, Some { Spanned { name, span }}, _, _, scope, _).

// `let` declarations
//
// Let declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// let foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(file, name, scope, Some { span }, AnyIdStmt { stmt }, false, false, UserDefined { scope }) :-
    LetDecl(stmt, file, Some { pat }, _, _),
    Statement(stmt, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// `const` declarations
//
// Const declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// const foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(file, name, scope, Some { span }, AnyIdStmt { stmt }, false, false, UserDefined { scope }) :-
    ConstDecl(stmt, file, Some { pat }, _, _),
    Statement(stmt, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// `var` declarations
//
// Var declarations bubble up to the nearest function-level block
//
// ```js
// // Scope: { ... }
// function foo() {
//     // Scope: { baz, ... }
//     var baz = 10;
//     // Scope: { baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(file, name, nearest, Some { span }, AnyIdStmt { stmt }, false, false, UserDefined { scope }) :-
    VarDecl(stmt, file, Some { pat }, _, _),
    Statement(stmt, file, _, scope, _),
    // Bubble `var` up to the nearest function-level scope
    FunctionLevelScope(scope, nearest, file, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// Function declarations
//
// ```js
// // Scope: { foo, ... }
// function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { foo, ... }
// ```
//
NameInScope(file, name, nearest, Some { span }, AnyIdFunc { func }, false, false, UserDefined { scope }) :-
    Function(func, file, Some { Spanned { name, span }}, scope, _, _),
    // Bubble functions up to the nearest function-level scope
    FunctionLevelScope(scope, nearest, file, _).

// Introduce function arguments within the body of their enclosing function
//
// ```js
// // Scope: { ... }
// function foo(bar, baz) {
//     // Scope: { bar, baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(file, name, body, Some { span }, AnyIdFunc { func }, implicit, true, UserDefined { scope }) :-
    FunctionArg(func, file, pat, implicit),
    Function(func, file, _, scope, body, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// Introduce closure arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// ((bar, baz) => {
//     // Scope: { bar, baz, ... }
// });
// // Scope: { ... }
// ```
//
// TODO: Can we address Expr/Stmt at the same time instead of seperate rules?
NameInScope(file, name, scope, Some { span }, AnyIdExpr { expr }, false, true, UserDefined { scope }) :-
    ArrowParam(expr, file, pat),
    Arrow(expr, file, Some { Left { body }}),
    Expression(body, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

NameInScope(file, name, scope, Some { span }, AnyIdExpr { expr }, false, true, UserDefined { scope }) :-
    ArrowParam(expr, file, pat),
    Arrow(expr, file, Some { Right { body }}),
    Statement(body, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// Inline function names
//
// Inline functions that are named only have their names added inside their bodies.
// The function names are marked as implict, since their name matters for weird
// meta-programming stuff.
//
// ```js
// // Scope: { ... }
// let _ = function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { ... }
// ```
//
// TODO: Make the implicit be configured by directives
NameInScope(file, name, scope, Some { span }, AnyIdExpr { expr }, true, false, UserDefined { scope }) :-
    InlineFunc(expr, file, Some { Spanned { name, span }}, Some { body }),
    Statement(body, file, _, scope, _).

// Introduce inline function arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// let _ = function(bar, baz) {
//     // Scope: { bar, baz, ... }
// };
// // Scope: { ... }
// ```
//
NameInScope(file, name, scope, Some { span }, AnyIdExpr { expr }, false, true, UserDefined { scope }) :-
    InlineFuncParam(expr, file, pat),
    InlineFunc(expr, file, _, Some { body }),
    Statement(body, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// `catch` statement patterns
NameInScope(file, name, scope, Some { span }, AnyIdStmt { catcher }, false, false, UserDefined { scope }) :-
    Try(stmt, file, _, TryHandler { Some { error }, Some { catcher } }, _),
    Statement(expr, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(error.bound_vars()),
    Spanned { var name, var span } = bound_var.

// Class methods and static class methods
NameInScope(file, name, scope, Some { span }, AnyIdClass { class }, implicit, true, UserDefined { scope }) :-
    Class(class, file, _, _, Some { elements }, _, _),
    var elem = FlatMap(elements),
    Some { (var params, var body) } = elem.ival().method_comps(),
    Statement(body, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(params.flatmap(|param| param.bound_vars())),
    (Spanned { var name, var span }, var implicit) = bound_var.

// Method properties, getters and setters
NameInScope(file, name, scope, Some { span }, AnyIdExpr { expr }, implicit, true, UserDefined { scope }) :-
    Property(expr, file, _, Some { val }),
    Some { (var params, var body) } = val.method_comps(),
    Statement(body, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(params.flatmap(|param| param.bound_vars())),
    (Spanned { var name, var span }, var implicit) = bound_var.

// Walk variables down scopes
NameInScope(file, name, to, span, declared_in, implicit, is_arg, origin) :-
    NameInScope(file, name, from, span, declared_in, implicit, is_arg, origin),
    ChildScope(from, to, file).
