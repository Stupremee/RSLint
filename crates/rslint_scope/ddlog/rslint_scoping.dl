import vec
import ast
import utils
import inputs

// Build the scope graph, unrolling the parent<-child relationships to full trees
//
// Given
// ```
// a<-b
// b<-c
// b<-d
// ```
// It will produce
// ```
// a
// ├-b
// │ └┐  
// │  ├╴c
// │  └╴d 
// ├╴c
// └╴d
// ```
//
relation ChildScope(parent: Scope, child: Scope)
ChildScope(parent, child) :- InputScope(parent, child), parent != child.
ChildScope(parent, child) :- InputScope(parent, interum), ChildScope(interum, child), parent != child.

relation ClosestFunction(scope: Scope, func: FuncId)
ClosestFunction(body, func) :- Function(func, _, _, body).
ClosestFunction(scope, func) :- Function(func, _, _, body), ChildScope(body, scope).

// The `NameInScope` relation gives every name/symbol/ident that's defined for any given scope.
// Names are walked down children scopes, meaning all children have access to the variables of
// their parent scope(s)
//
// ```
// // 'a defines the `foo` symbol
// 'a: { foo }
//  │
//  │ // 'b defines the `bar` symbol and inherits
//  │ // the `foo` symbol
//  └-'b: { foo, bar }
// ```
//
relation NameInScope(name: Name, scope: Scope, span: Option<Span>, declared_in: AnyId)

// An index that returns all variables avaliable in a given scope
index Index_VariablesForScope(scope: Scope) on NameInScope(_, scope, _, _)

// An index that returns all variables by the given name in the given scope
index Index_VariableInScope(scope: Scope, variable: Name) on NameInScope(variable, scope, _, _)

// Add implicit globals to every scope
NameInScope(name, scope, None, AnyIdGlobal { global }) :-
    ImplicitGlobal(global, name),
    EveryScope(scope).

// Import declarations
NameInScope(name.data, scope, Some { name.span }, AnyIdImport { id }) :-
    ImportDecl(id, clause),
    var name = FlatMap(clause.free_variables()),
    EveryScope(scope).

// Class declarations
//
// Class declarations create a new scope when they're declared,
// so we add the class's name within that scope
//
// ```js
// // Scope: { ... }
// class Baz { }
// // Scope: { Baz, ... }
// ```
//
NameInScope(name.data, scope, Some { name.span }, AnyIdClass { class }) :-
    Class(class, Some { name }, _, _, scope).

// `let` declarations
//
// Let declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// let foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(name.data, scope, Some { name.span }, AnyIdStmt { stmt }) :-
    LetDecl(stmt, Some { pat }, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, scope, _).

// `const` declarations
//
// Const declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// const foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(name.data, scope, Some { name.span }, AnyIdStmt { stmt }) :-
    ConstDecl(stmt, Some { pat }, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, scope, _).

// `var` declarations
//
// Var declarations bubble up to the nearest function-level block
//
// ```js
// // Scope: { ... }
// function foo() {
//     // Scope: { baz, ... }
//     var baz = 10;
//     // Scope: { baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(name.data, scope, Some { name.span }, AnyIdStmt { stmt }) :-
    VarDecl(stmt, Some { pat }, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, decl_scope, _),
    // Bubble `var` up to the nearest function's scope
    ClosestFunction(decl_scope, func), // FIXME: This or the Function clause is wrong
    Function(func, _, _, scope).

NameInScope(name.data, scope, Some { name.span }, AnyIdStmt { stmt }) :-
    VarDecl(stmt, Some { pat }, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, scope, _),
    // For `var` declarations not within a function, use the declaration scope
    not ClosestFunction(scope, _).

// Function declarations
//
// Function declarations don't initalize a new scope, so we add the function's
// name to the scope it was declared in
//
// ```js
// // Scope: { foo, ... }
// function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { foo, ... }
// ```
//
NameInScope(name.data, scope, Some { name.span }, AnyIdFunc { func }) :-
    Function(func, Some { name }, scope, _).

// Introduce function arguments within the body of their enclosing function
//
// ```js
// // Scope: { ... }
// function foo(bar, baz) {
//     // Scope: { bar, baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(name.data, body, Some { name.span }, AnyIdFunc { func }) :-
    FunctionArg(func, pat),
    var name = FlatMap(pat.bound_vars()),
    Function(func, _, _, body).

// Introduce closure arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// ((bar, baz) => {
//     // Scope: { bar, baz, ... }
// });
// // Scope: { ... }
// ```
//
NameInScope(name.data, scope, Some { name.span }, AnyIdExpr { expr }) :-
    ArrowParam(expr, pat),
    var name = FlatMap(pat.bound_vars()),
    // Get the body's expression and put the parameters in-scope
    // there, not within the arrow expression's scope
    // TODO: Can I address Expr/Stmt at the same time instead
    //       of seperate rules?
    Arrow(expr, Some { Left { expr_body }}),
    Expression(expr_body, _, scope, _).

NameInScope(name.data, scope, Some { name.span }, AnyIdExpr { expr }) :-
    ArrowParam(expr, pat),
    var name = FlatMap(pat.bound_vars()),
    // Get the body's statement and put the parameters in-scope
    // there, not within the arrow expression's scope
    Arrow(expr, Some { Right { stmt_body }}),
    Statement(stmt_body, _, scope, _).

// Inline function names
//
// Inline functions that are named are treated like normal functions
// and added to their enclosing scope
//
// ```js
// // Scope: { foo, ... }
// let _ = function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { foo, ... }
// ```
//
NameInScope(name.data, scope, Some { name.span }, AnyIdExpr { expr }) :-
    InlineFunc(expr, Some { name }, _),
    Expression(expr, _, scope, _).

// Introduce inline function arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// let _ = function(bar, baz) {
//     // Scope: { bar, baz, ... }
// };
// // Scope: { ... }
// ```
//
NameInScope(name.data, scope, Some { name.span }, AnyIdExpr { expr }) :-
    InlineFuncParam(expr, pat),
    var name = FlatMap(pat.bound_vars()),
    InlineFunc(expr, _, Some { body }),
    Statement(body, _, scope, _).

// Walk variables down scopes
NameInScope(name, scope, span, declared_in) :-
    NameInScope(name, interum, span, declared_in),
    ChildScope(interum, scope).

// The successors of an expression, property accesses or method calls
relation ChainedWith(object: ExprId, property: ExprId)
ChainedWith(object, property) :- BracketAccess(_, Some { object }, Some { property }).
ChainedWith(object, property) :- DotAccess(property, Some { object }, _).
ChainedWith(object, property) :- ChainedWith(object, interum), ChainedWith(interum, property).

relation WithinTypeofExpr(type_of: ExprId, expr: ExprId)
// `typeof not_defined`
WithinTypeofExpr(type_of, expr) :- UnaryOp(type_of, Some { UnaryTypeof }, Some { expr }).

// `typeof (not_defined)`
WithinTypeofExpr(type_of, grouped) :-
    WithinTypeofExpr(type_of, expr),
    Expression(expr, ExprGrouping { Some { grouped }}, _, _).

// `typeof (defined, not_defined)`
WithinTypeofExpr(type_of, last) :-
    WithinTypeofExpr(type_of, expr),
    Expression(expr, ExprSequence { sequence }, _, _),
    Some { var last } = sequence.last().

output relation TypeofUndefinedAlwaysUndefined(whole_expr: ExprId, undefined_expr: ExprId)
TypeofUndefinedAlwaysUndefined(whole_expr, undefined_expr) :-
    NameRef(undefined_expr, name),
    Expression(undefined_expr, ExprNameRef, scope, span),
    not NameInScope(name, scope, _, _),
    // Expressions like `typeof not_undefined` are allowed under InvalidNameUse
    // and are instead output through TypeofUndefinedAlwaysUndefined
    WithinTypeofExpr(whole_expr, undefined_expr).

// Variable usages (`let` and `const` predecls or undefined symbols) that don't
// have an accompanying variable in scope are reported
// TODO: Use a levenshtein aggregate to try and correct and/or look in children
//       scopes for a declaration
output relation InvalidNameUse(name: Name, scope: Scope, span: Span)
InvalidNameUse(name, scope, span) :-
    NameRef(expr, name),
    Expression(expr, ExprNameRef, scope, span),
    not NameInScope(name, scope, _, _),
    // Expressions like `typeof not_undefined` are allowed under InvalidNameUse
    // and are instead output through TypeofUndefinedAlwaysUndefined
    not WithinTypeofExpr(_, expr),
    not ChainedWith(_, expr).

// Assignments
InvalidNameUse(name.data, scope, name.span) :-
    Assign(expr, Some { Left { pat }}, _, _),
    Expression(expr, _, scope, _),
    var name = FlatMap(pat.bound_vars()),
    not NameInScope(name.data, scope, _, _).

index Index_InvalidNameUse(name: Name) on InvalidNameUse(name, _, _)

// `var` usages that happen before the declaration
output relation VarUseBeforeDeclaration(name: Name, used_in: Span, declared_in: Span)
VarUseBeforeDeclaration(name, used_in, declared_in) :-
    NameRef(expr, name),
    Expression(expr, ExprNameRef, used_scope, used_in),
    NameInScope(name, used_scope, _, AnyIdStmt { .stmt = stmt }),
    Statement(stmt, StmtVarDecl, declared_scope, declared_in),
    ChildScope(used_scope, declared_scope).

index Index_VarUseBeforeDeclaration(name: Name) on VarUseBeforeDeclaration(name, _, _)
