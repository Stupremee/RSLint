import vec
import ast
import utils
import group
import inputs

// Build the scope graph, unrolling the parent<-child relationships to full trees
//
// Given
// ```
// a<-b
// b<-c
// b<-d
// ```
// It will produce
// ```
// a
// ├-b
// │ └┐  
// │  ├╴c
// │  └╴d 
// ├╴c
// └╴d
// ```
//
relation ChildScope(parent: ScopeId, child: ScopeId)
index ChildScopeByParent(parent: ScopeId) on ChildScope(parent, _)

ChildScope(parent, child) :- InputScope(parent, child), parent != child.
ChildScope(parent, child) :- InputScope(parent, interum), ChildScope(interum, child), parent != child.

relation ClosestFunction(scope: ScopeId, func: FuncId)
ClosestFunction(body, func) :- Function(func, _, _, body, _).
ClosestFunction(scope, func) :- Function(func, _, _, body, _), ChildScope(body, scope).

// The `NameInScope` relation gives every name/symbol/ident that's defined for any given scope.
// Names are walked down children scopes, meaning all children have access to the variables of
// their parent scope(s)
//
// ```
// // 'a defines the `foo` symbol
// 'a: { foo }
//  │
//  │ // 'b defines the `bar` symbol and inherits
//  │ // the `foo` symbol
//  └-'b: { foo, bar }
// ```
//
relation NameInScope(
    file: FileId,
    name: Name,
    scope: ScopeId,
    span: Option<Span>,
    declared_in: AnyId,
    implicit: bool,
)

// An index that returns all variables avaliable in a given scope
index Index_VariablesForScope(file: FileId, scope: ScopeId) on NameInScope(file, _, scope, _, _, _)

// An index that returns all variables by the given name in the given scope
index Index_VariableInScope(file: FileId, scope: ScopeId, variable: Name) on NameInScope(file, variable, scope, _, _, _)

// Add implicit globals to every scope
NameInScope(global.file, name, scope, None, AnyIdGlobal { global }, true) :-
    ImplicitGlobal(global, name),
    EveryScope(scope),
    scope.file == global.file.

// Import declarations
NameInScope(id.file, name.data, scope, Some { name.span }, AnyIdImport { id }, false) :-
    ImportDecl(id, clause),
    var name = FlatMap(clause.free_variables()),
    EveryScope(scope),
    scope.file == id.file.

// Class declarations
//
// Class declarations create a new scope when they're declared,
// so we add the class's name within that scope
//
// ```js
// // Scope: { ... }
// class Baz { }
// // Scope: { Baz, ... }
// ```
//
NameInScope(class.file, name.data, scope, Some { name.span }, AnyIdClass { class }, false) :-
    Class(class, Some { name }, _, _, scope, _).

// `let` declarations
//
// Let declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// let foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(stmt.file, name.data, scope, Some { name.span }, AnyIdStmt { stmt }, false) :-
    LetDecl(stmt, Some { pat }, _, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, scope, _).

// `const` declarations
//
// Const declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// const foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(stmt.file, name.data, scope, Some { name.span }, AnyIdStmt { stmt }, false) :-
    ConstDecl(stmt, Some { pat }, _, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, scope, _).

// `var` declarations
//
// Var declarations bubble up to the nearest function-level block
//
// ```js
// // Scope: { ... }
// function foo() {
//     // Scope: { baz, ... }
//     var baz = 10;
//     // Scope: { baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(stmt.file, name.data, scope, Some { name.span }, AnyIdStmt { stmt }, false) :-
    VarDecl(stmt, Some { pat }, _, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, decl_scope, _),
    // Bubble `var` up to the nearest function's scope
    ClosestFunction(decl_scope, func), // FIXME: This or the Function clause is wrong
    Function(func, _, _, scope, _).

NameInScope(stmt.file, name.data, scope, Some { name.span }, AnyIdStmt { stmt }, false) :-
    VarDecl(stmt, Some { pat }, _, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, scope, _),
    // For `var` declarations not within a function, use the declaration scope
    not ClosestFunction(scope, _).

// Function declarations
//
// Function declarations don't initalize a new scope, so we add the function's
// name to the scope it was declared in
//
// ```js
// // Scope: { foo, ... }
// function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { foo, ... }
// ```
//
NameInScope(func.file, name.data, scope, Some { name.span }, AnyIdFunc { func }, false) :-
    Function(func, Some { name }, scope, _, _).

// Introduce function arguments within the body of their enclosing function
//
// ```js
// // Scope: { ... }
// function foo(bar, baz) {
//     // Scope: { bar, baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(func.file, name.data, body, Some { name.span }, AnyIdFunc { func }, implicit) :-
    FunctionArg(func, pat, implicit),
    var name = FlatMap(pat.bound_vars()),
    Function(func, _, _, body, _).

// Introduce closure arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// ((bar, baz) => {
//     // Scope: { bar, baz, ... }
// });
// // Scope: { ... }
// ```
//
NameInScope(expr.file, name.data, scope, Some { name.span }, AnyIdExpr { expr }, false) :-
    ArrowParam(expr, pat),
    // Get the body's expression and put the parameters in-scope
    // there, not within the arrow expression's scope
    // TODO: Can I address Expr/Stmt at the same time instead
    //       of seperate rules?
    Arrow(expr, Some { Left { expr_body }}),
    Expression(expr_body, _, scope, _),
    var name = FlatMap(pat.bound_vars()).

NameInScope(expr.file, name.data, scope, Some { name.span }, AnyIdExpr { expr }, false) :-
    ArrowParam(expr, pat),
    var name = FlatMap(pat.bound_vars()),
    // Get the body's statement and put the parameters in-scope
    // there, not within the arrow expression's scope
    Arrow(expr, Some { Right { stmt_body }}),
    Statement(stmt_body, _, scope, _).

// Inline function names
//
// Inline functions that are named are treated like normal functions
// and added to their enclosing scope
//
// ```js
// // Scope: { foo, ... }
// let _ = function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { foo, ... }
// ```
//
NameInScope(expr.file, name.data, scope, Some { name.span }, AnyIdExpr { expr }, false) :-
    InlineFunc(expr, Some { name }, _),
    Expression(expr, _, scope, _).

// Introduce inline function arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// let _ = function(bar, baz) {
//     // Scope: { bar, baz, ... }
// };
// // Scope: { ... }
// ```
//
NameInScope(expr.file, name.data, scope, Some { name.span }, AnyIdExpr { expr }, false) :-
    InlineFuncParam(expr, pat),
    InlineFunc(expr, _, Some { body }),
    Statement(body, _, scope, _),
    var name = FlatMap(pat.bound_vars()).

// `catch` statement patterns
NameInScope(stmt.file, name.data, scope, Some { name.span }, AnyIdStmt { catcher }, false) :-
    Try(stmt, _, TryHandler { Some { error }, Some { catcher } }, _),
    Statement(expr, _, scope, _),
    var name = FlatMap(error.bound_vars()).

// Walk variables down scopes
NameInScope(file, name, scope, span, declared_in, implicit) :-
    NameInScope(file, name, interum, span, declared_in, implicit),
    ChildScope(interum, scope).


relation VariableUsages(name: Name, scope: ScopeId, declared_in: AnyId)
VariableUsages(name, scope, declared) :-
    NameInScope(file, name, scope, _, declared, _),
    NameRef(expr, name),
    file == expr.file,
    Expression(expr, _, scope, _).


output relation UnusedVariables(name: Name, declared: AnyId, span: Span)
// TODO: Are these to rules all that's needed? Is the grouping bs even
//       useful?
UnusedVariables(name, declared, span) :-
    NameInScope(file, name, _, Some { span }, declared, false),
    not declared.is_global(),
    not IsExported(file, declared),
    not VariableUsages(name, _, declared).

UnusedVariables(name, declared, span) :-
    NameInScope(file, name, _, Some { span }, declared @ AnyIdGlobal { global }, false),
    not ImplicitGlobal(global, _),
    not IsExported(file, declared),
    not VariableUsages(name, _, declared).


// The successors of an expression, property accesses or method calls
relation ChainedWith(object: ExprId, property: ExprId)
ChainedWith(object, property) :- BracketAccess(_, Some { object }, Some { property }).
ChainedWith(object, property) :- DotAccess(property, Some { object }, _).
ChainedWith(object, property) :- ChainedWith(object, interum), ChainedWith(interum, property).


relation WithinTypeofExpr(type_of: ExprId, expr: ExprId)
// `typeof not_defined`
WithinTypeofExpr(type_of, expr) :- UnaryOp(type_of, Some { UnaryTypeof }, Some { expr }).

// `typeof (not_defined)`
WithinTypeofExpr(type_of, grouped) :-
    WithinTypeofExpr(type_of, expr),
    Expression(expr, ExprGrouping { Some { grouped }}, _, _).

// `typeof (defined, not_defined)`
WithinTypeofExpr(type_of, last) :-
    WithinTypeofExpr(type_of, expr),
    Expression(expr, ExprSequence { sequence }, _, _),
    Some { var last } = sequence.last().


output relation TypeofUndefinedAlwaysUndefined(whole_expr: ExprId, undefined_expr: ExprId)
TypeofUndefinedAlwaysUndefined(whole_expr, undefined_expr) :-
    NameRef(undefined_expr, name),
    Expression(undefined_expr, ExprNameRef, scope, span),
    not NameInScope(scope.file, name, scope, _, _, _),
    // Expressions like `typeof not_undefined` are allowed under InvalidNameUse
    // and are instead output through TypeofUndefinedAlwaysUndefined
    WithinTypeofExpr(whole_expr, undefined_expr).


// Variable usages (`let` and `const` predecls or undefined symbols) that don't
// have an accompanying variable in scope are reported
// TODO: Use a levenshtein aggregate to try and correct and/or look in children
//       scopes for a declaration
output relation InvalidNameUse(name: Name, scope: ScopeId, span: Span)
InvalidNameUse(name, scope, span) :-
    NameRef(expr, name),
    Expression(expr, ExprNameRef, scope, span),
    not NameInScope(expr.file, name, scope, _, _, _),
    // Expressions like `typeof not_undefined` are allowed under InvalidNameUse
    // and are instead output through TypeofUndefinedAlwaysUndefined
    not WithinTypeofExpr(_, expr),
    not ChainedWith(_, expr).

// Assignments
InvalidNameUse(name.data, scope, name.span) :-
    Assign(expr, Some { Left { pat }}, _, _),
    Expression(expr, _, scope, _),
    var name = FlatMap(pat.bound_vars()),
    not NameInScope(expr.file, name.data, scope, _, _, _).


// `var` usages that happen before the declaration
output relation VarUseBeforeDeclaration(name: Name, used_in: Span, declared_in: Span)
VarUseBeforeDeclaration(name, used_in, declared_in) :-
    NameRef(expr, name),
    Expression(expr, ExprNameRef, used_scope, used_in),
    NameInScope(expr.file, name, used_scope, _, AnyIdStmt { .stmt = stmt }, _),
    Statement(stmt, StmtVarDecl, declared_scope, declared_in),
    ChildScope(used_scope, declared_scope).

relation IsExported(file: FileId, id: AnyId)

IsExported(file, AnyIdFunc { id }) :-
    Function(id, _, _, _, true),
    var file = id.file.

IsExported(file, AnyIdClass { id }) :-
    Class(id, _, _, _, _, true),
    var file = id.file.

IsExported(file, AnyIdStmt { id }) :-
    VarDecl(id, _, _, true),
    var file = id.file.

IsExported(file, AnyIdStmt { id }) :-
    LetDecl(id, _, _, true),
    var file = id.file.

IsExported(file, AnyIdStmt { id }) :-
    ConstDecl(id, _, _, true),
    var file = id.file.
