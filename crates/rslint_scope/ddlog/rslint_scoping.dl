import vec

#[has_side_effects]
extern function debug(message: string)

typedef Scope = Scope { id: u32 }
typedef Name = istring

// Ids
typedef GlobalId = GlobalId { id: u32 }
typedef ClassId = ClassId { id: u32 }
typedef FuncId = FuncId { id: u32 }
typedef StmtId = StmtId { id: u32 }
typedef ExprId = ExprId { id: u32 }
typedef AnyId =
    AnyIdGlobal { global: GlobalId }
    | AnyIdClass { class: ClassId }
    | AnyIdFunc { func: FuncId }
    | AnyIdStmt { stmt: StmtId }
    | AnyIdExpr { expr: ExprId }

typedef Span = Span { start: u32, end: u32 }

function to_string(span: Span): string {
    "Span{.start = ${span.start}, .end = ${span.end}}"
}

typedef OneOf<'A, 'B, 'C> =
    First { a: 'A }
    | Second { b: 'B }
    | Third { c: 'C }

typedef Pattern =
    SinglePattern { name: Option<Name> }
    | RestPattern { rest: Option<Intern<Pattern>> }
    | AssignPattern { key: Option<Intern<Pattern>>, value: Option<ExprId> }
    | ObjectPattern { props: Vec<Intern<ObjectPatternProp>> }
    | ArrayPattern { elems: Vec<Intern<Pattern>> }

function bound_vars(pat: IPattern): Vec<Name> {
    match (pat.ival()) {
        SinglePattern { Some { name }} -> [name],
        RestPattern { Some { rest }} -> rest.bound_vars(),
        AssignPattern { Some { key }, _ } -> key.bound_vars(),
        ObjectPattern { props } -> props.flatmap(|prop| prop.bound_vars()),
        ArrayPattern { elems } -> elems.flatmap(|elem| elem.bound_vars()),
        _ -> vec_empty()
    }
}

typedef ObjectPatternProp =
    ObjAssignPattern { assign_key: Option<Intern<Pattern>>, assign_value: Option<ExprId> }
    | ObjKeyValuePattern { key: Option<PropertyKey>, value: Option<Intern<Pattern>> }
    | ObjRestPattern { rest: Option<Intern<Pattern>> }
    | ObjSinglePattern { name: Option<Name> }

function bound_vars(pat: IObjectPatternProp): Vec<Name> {
    match (pat.ival()) {
        ObjAssignPattern { Some { key }, _ } -> key.bound_vars(),
        ObjKeyValuePattern { _, Some { value }} -> value.bound_vars(),
        ObjRestPattern { Some { rest }} -> rest.bound_vars(),
        ObjSinglePattern { Some { name }} -> [name],
        _ -> vec_empty()
    }
}

typedef IPattern = Intern<Pattern>
typedef IObjectPatternProp = Intern<ObjectPatternProp>

typedef StmtKind =
    StmtVarDecl
    | StmtLetDecl
    | StmtConstDecl
    // No statement relation, use expr_id to find the
    // associated expression
    | StmtExpr { expr_id: Option<ExprId> }
    | StmtReturn
    | StmtIf
    | StmtBreak
    | StmtDoWhile
    | StmtWhile
    | StmtFor
    | StmtForIn
    | StmtContinue
    | StmtWith
    | StmtLabel
    | StmtSwitch
    | StmtThrow
    | StmtTry
    // No associated relation, they carry no data
    | StmtDebugger
    // No associated relation, literally nothing
    | StmtEmpty

typedef ExprKind =
    ExprLit { kind: LitKind }
    | ExprNameRef
    | ExprYield
    | ExprAwait
    | ExprArrow
    | ExprUnaryOp
    | ExprBinOp
    | ExprTernary
    // No associated relation
    | ExprThis
    | ExprTemplate
    | ExprArray
    // Associated with the Property relation
    | ExprObject
    | ExprGrouping { inner: Option<ExprId> }
    | ExprBracket
    | ExprDot
    | ExprNew
    | ExprCall
    | ExprAssign
    | ExprSequence { exprs: Vec<ExprId> }
    | ExprNewTarget
    | ExprImportMeta
    | ExprInlineFunc
    | ExprSuperCall { args: Option<Vec<ExprId>> }
    | ExprImportCall { arg: Option<ExprId> }
    | ExprClass

typedef UnaryOperand =
    UnaryIncrement
    | UnaryDecrement
    | UnaryDelete
    | UnaryVoid
    | UnaryTypeof
    | UnaryPlus
    | UnaryMinus
    | UnaryBitwiseNot
    | UnaryLogicalNot
    | UnaryAwait

typedef BinOperand =
    BinLessThan
    | BinGreaterThan
    | BinLessThanOrEqual
    | BinGreaterThanOrEqual
    | BinEquality
    | BinStrictEquality
    | BinInequality
    | BinStrictInequality
    | BinPlus
    | BinMinus
    | BinTimes
    | BinDivide
    | BinRemainder
    | BinExponent
    | BinLeftShift
    | BinRightShift
    | BinUnsignedRightShift
    | BinBitwiseAnd
    | BinBitwiseOr
    | BinBitwiseXor
    | BinNullishCoalescing
    | BinLogicalOr
    | BinLogicalAnd
    | BinIn
    | BinInstanceof

typedef AssignOperand =
    OpAssign
    | OpAddAssign
    | OpSubtractAssign
    | OpTimesAssign
    | OpRemainderAssign
    | OpExponentAssign
    | OpLeftShiftAssign
    | OpRightShiftAssign
    | OpUnsignedRightShiftAssign
    | OpBitwiseAndAssign
    | OpBitwiseOrAssign
    | OpBitwiseXorAssign
    | OpLogicalAndAssign
    | OpLogicalOrAssign
    | OpNullishCoalescingAssign

typedef LitKind = LitNumber | LitBigInt | LitString | LitNull | LitBool | LitRegex
typedef ForInit = ForDecl { stmt_id: Option<StmtId> } | ForExpr { expr_id: ExprId }
typedef SwitchClause = CaseClause { test: Option<ExprId> } | DefaultClause
typedef TryHandler = TryHandler { error: Option<IPattern>, body: Option<StmtId> }
typedef ArrayElement = ArrExpr { expr: ExprId } | ArrSpread { spread: Option<ExprId> }

typedef PropertyKey =
    ComputedKey { prop: Option<ExprId> }
    | LiteralKey { lit: ExprId }
    | IdentKey { ident: Name }

typedef PropertyVal =
    PropLit { lit: Option<ExprId> }
    | PropGetter { body: Option<StmtId> }
    | PropSetter { params: Option<Vec<IPattern>> }
    | PropSpread { value: Option<ExprId> }
    | PropInit { value: Option<ExprId> }
    | PropIdent
    | PropMethod { params: Option<Vec<IPattern>>, body: Option<StmtId> }

typedef ClassElement =
    ClassEmptyElem
    | ClassMethod {
        name: Option<PropertyKey>,
        params: Option<Vec<IPattern>>,
        body: Option<StmtId>
    }
    | ClassStaticMethod {
        name: Option<PropertyKey>,
        params: Option<Vec<IPattern>>,
        body: Option<StmtId>
    }

typedef IClassElement = Intern<ClassElement>

// The input scope relationships, just map parent<-child for one generation
// TODO: Scope spans, make clear if a span is implicit or explicit
input relation InputScope(parent: Scope, child: Scope)
input relation EveryScope(scope: Scope)

// Functions
input relation Function(id: FuncId, name: Option<Name>, scope: Scope)
input relation FunctionArg(parent_func: FuncId, pattern: IPattern)

// Statements
input relation Statement(id: StmtId, kind: StmtKind, scope: Scope, span: Span)
input relation VarDecl(stmt_id: StmtId, pattern: Option<IPattern>, value: Option<ExprId>)
input relation LetDecl(stmt_id: StmtId, pattern: Option<IPattern>, value: Option<ExprId>)
input relation ConstDecl(stmt_id: StmtId, pattern: Option<IPattern>, value: Option<ExprId>)
input relation Return(stmt_id: StmtId, value: Option<ExprId>)
input relation If(stmt_id: StmtId, cond: Option<ExprId>, if_body: Option<StmtId>, else_body: Option<StmtId>)
input relation Break(stmt_id: StmtId, label: Option<Name>)
input relation DoWhile(stmt_id: StmtId, body: Option<StmtId>, cond: Option<ExprId>)
input relation While(stmt_id: StmtId, cond: Option<ExprId>, body: Option<StmtId>)
input relation For(stmt_id: StmtId, init: Option<ForInit>, test: Option<ExprId>, update: Option<ExprId>, body: Option<StmtId>)
input relation ForIn(stmt_id: StmtId, elem: Option<ForInit>, collection: Option<ExprId>, body: Option<StmtId>)
input relation Continue(stmt_id: StmtId, label: Option<Name>)
input relation With(stmt_id: StmtId, cond: Option<ExprId>, body: Option<StmtId>)
input relation Label(stmt_id: StmtId, name: Option<Name>, body: Option<StmtId>)
// Switch statements & cases
input relation Switch(stmt_id: StmtId, test: Option<ExprId>)
input relation SwitchCase(stmt_id: StmtId, case: SwitchClause, body: Option<StmtId>)
input relation Throw(stmt_id: StmtId, exception: Option<ExprId>)
input relation Try(stmt_id: StmtId, body: Option<StmtId>, handler: TryHandler, finalizer: Option<StmtId>)

// Expressions
input relation Expression(id: ExprId, kind: ExprKind, scope: Scope, span: Span)
// Literals
input relation ExprNumber(expr_id: ExprId, value: double)
input relation ExprBigInt(expr_id: ExprId, value: bigint)
input relation ExprString(expr_id: ExprId, value: istring)
input relation ExprBool(expr_id: ExprId, value: bool)
input relation NameRef(expr_id: ExprId, value: Name)
input relation Yield(expr_id: ExprId, value: Option<ExprId>)
input relation Await(expr_id: ExprId, value: Option<ExprId>)
input relation Arrow(expr_id: ExprId, body: Option<Either<ExprId, StmtId>>)
input relation ArrowParam(expr_id: ExprId, param: IPattern) // TODO: Inline this?
input relation UnaryOp(expr_id: ExprId, op: Option<UnaryOperand>, expr: Option<ExprId>)
input relation BinOp(expr_id: ExprId, op: Option<BinOperand>, lhs: Option<ExprId>, rhs: Option<ExprId>)
input relation Ternary(expr_id: ExprId, test: Option<ExprId>, true_val: Option<ExprId>, false_val: Option<ExprId>)
input relation Template(expr_id: ExprId, tag: Option<ExprId>, elements: Vec<ExprId>)
input relation Array(expr_id: ExprId, elements: Vec<ArrayElement>)
input relation Property(expr_id: ExprId, key: Option<PropertyKey>, val: Option<PropertyVal>)
input relation BracketAccess(expr_id: ExprId, object: Option<ExprId>, prop: Option<ExprId>)
input relation DotAccess(expr_id: ExprId, object: Option<ExprId>, prop: Option<Name>)
input relation New(expr_id: ExprId, object: Option<ExprId>, args: Option<Vec<ExprId>>)
input relation Call(expr_id: ExprId, callee: Option<ExprId>, args: Option<Vec<ExprId>>)
input relation Assign(expr_id: ExprId, lhs: Option<Either<IPattern, ExprId>>, rhs: Option<ExprId>, op: Option<AssignOperand>)
input relation InlineFunc(expr_id: ExprId, name: Option<Name>, body: Option<StmtId>)
input relation InlineFuncParam(expr_id: ExprId, param: IPattern) // TODO: Inline this?
input relation ClassExpr(expr_id: ExprId, elements: Option<Vec<IClassElement>>)

// Class declarations
input relation Class(id: ClassId, name: Option<Name>, parent: Option<ExprId>, elements: Option<Vec<IClassElement>>, scope: Scope)

// Globals
input relation ImplicitGlobal(id: GlobalId, name: Name)

// Build the scope graph, unrolling the parent<-child relationships to full trees
//
// Given
// ```
// a<-b
// b<-c
// b<-d
// ```
// It will produce
// ```
// a
// ├-b
// │ └┐  
// │  ├╴c
// │  └╴d 
// ├╴c
// └╴d
// ```
//
relation ChildScope(parent: Scope, child: Scope)
ChildScope(parent, child) :- InputScope(parent, child).
ChildScope(parent, child) :- InputScope(parent, interum), InputScope(interum, child).

relation ClosestFunction(scope: Scope, func: FuncId)
ClosestFunction(scope, func) :- Function(func, _, scope).
ClosestFunction(scope, func) :- Function(func, _, func_scope), ChildScope(func_scope, scope).

// The `NameInScope` relation gives every name/symbol/ident that's defined for any given scope.
// Names are walked down children scopes, meaning all children have access to the variables of
// their parent scope(s)
//
// ```
// // 'a defines the `foo` symbol
// 'a: { foo }
//  │
//  │ // 'b defines the `bar` symbol and inherits
//  │ // the `foo` symbol
//  ├-'b: { foo, bar }
// ```
//
relation NameInScope(name: Name, scope: Scope, declared_in: AnyId)

// Add implicit globals to every scope
NameInScope(name, scope, AnyIdGlobal { global }) :- ImplicitGlobal(global, name), EveryScope(scope).

// Class declarations
//
// Class declarations create a new scope when they're declared,
// so we add the class's name within that scope
//
// ```js
// // Scope: { ... }
// class Baz { }
// // Scope: { Baz, ... }
// ```
//
NameInScope(name, scope, AnyIdClass { class }) :- Class(class, Some { name }, _, _, scope).

// `let` declarations
//
// Let declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// let foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(name, scope, AnyIdStmt { stmt }) :-
    LetDecl(stmt, Some { pat }, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, scope, _).

// `const` declarations
//
// Const declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// const foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(name, scope, AnyIdStmt { stmt }) :-
    ConstDecl(stmt, Some { pat }, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, scope, _).

// `var` declarations
//
// Var declarations bubble up to the nearest function-level block
//
// ```js
// // Scope: { ... }
// function foo() {
//     // Scope: { baz, ... }
//     var baz = 10;
//     // Scope: { baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(name, scope, AnyIdStmt { stmt }) :-
    VarDecl(stmt, Some { pat }, _),
    var name = FlatMap(pat.bound_vars()),
    Statement(stmt, _, decl_scope, _),
    // Bubble `var` up to the nearest function's scope
    ClosestFunction(decl_scope, func),
    Function(func, _, scope).

// Function declarations
//
// Function declarations don't initalize a new scope, so we add the function's
// name to the scope it was declared in
//
// ```js
// // Scope: { foo, ... }
// function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { foo, ... }
// ```
//
NameInScope(name, scope, AnyIdFunc { func }) :- Function(func, Some { name }, scope).

// Introduce function arguments within the body of their enclosing function
//
// ```js
// // Scope: { ... }
// function foo(bar, baz) {
//     // Scope: { bar, baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(name, scope, AnyIdFunc { func }) :-
    FunctionArg(func, pat),
    var name = FlatMap(pat.bound_vars()),
    Function(func, _, scope).

// Introduce closure arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// ((bar, baz) => {
//     // Scope: { bar, baz, ... }
// });
// // Scope: { ... }
// ```
//
NameInScope(name, scope, AnyIdExpr { expr }) :-
    ArrowParam(expr, pat),
    var name = FlatMap(pat.bound_vars()),
    // Get the body's expression and put the parameters in-scope
    // there, not within the arrow expression's scope
    // TODO: Can I address Expr/Stmt at the same time instead
    //       of seperate rules?
    Arrow(expr, Some { Left { expr_body }}),
    Expression(expr_body, _, scope, _).

NameInScope(name, scope, AnyIdExpr { expr }) :-
    ArrowParam(expr, pat),
    var name = FlatMap(pat.bound_vars()),
    // Get the body's statement and put the parameters in-scope
    // there, not within the arrow expression's scope
    Arrow(expr, Some { Right { stmt_body }}),
    Statement(stmt_body, _, scope, _).

// Inline function names
//
// Inline functions that are named are treated like normal functions
// and added to their enclosing scope
//
// ```js
// // Scope: { foo, ... }
// let _ = function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { foo, ... }
// ```
//
NameInScope(name, scope, AnyIdExpr { expr }) :-
    InlineFunc(expr, Some { name }, _),
    Expression(expr, _, scope, _).

// Introduce inline function arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// let _ = function(bar, baz) {
//     // Scope: { bar, baz, ... }
// };
// // Scope: { ... }
// ```
//
NameInScope(name, scope, AnyIdExpr { expr }) :-
    InlineFuncParam(expr, pat),
    var name = FlatMap(pat.bound_vars()),
    InlineFunc(expr, _, Some { body }),
    Statement(body, _, scope, _).

// Walk variables down scopes
NameInScope(name, scope, declared_in) :-
    NameInScope(name, interum, declared_in),
    ChildScope(interum, scope).

// Variable usages (`let` and `const` predecls or undefined symbols) that don't
// have an accompanying variable in scope are reported
// TODO: Use a levenshtein aggregate to try and correct and/or look in children
//       scopes for a declaration
output relation InvalidNameUse(name: Name, scope: Scope, span: Span)
InvalidNameUse(name, scope, span) :-
    NameRef(expr, name),
    Expression(expr, ExprNameRef, scope, span),
    not NameInScope(name, scope, _).

// `var` usages that happen before the declaration
output relation VarUseBeforeDeclaration(name: Name, used_in: Span, declared_in: Span)
VarUseBeforeDeclaration(name, used_in, declared_in) :-
    NameRef(expr, name),
    Expression(expr, ExprNameRef, used_scope, used_in),
    NameInScope(name, used_scope, AnyIdStmt { .stmt = stmt }),
    Statement(stmt, StmtVarDecl, declared_scope, declared_in),
    ChildScope(used_scope, declared_scope).
