import vec
import ast
import utils
import group
import inputs

// Build the scope graph, unrolling the parent<-child relationships to full trees
//
// Given
// ```
// a<-b
// b<-c
// b<-d
// ```
// It will produce
// ```
// a
// ├-b
// │ └┐  
// │  ├╴c
// │  └╴d 
// ├╴c
// └╴d
// ```
//
relation ChildScope(parent: ScopeId, child: ScopeId, file: FileId)
index ChildScopeByParent(parent: ScopeId, file: FileId) on ChildScope(parent, _, file)

ChildScope(parent, child, file) :- InputScope(parent, child, file), parent != child.
ChildScope(parent, child, file) :-
    InputScope(parent, interum, file),
    ChildScope(interum, child, file),
    parent != child.

// Function-level scoping, the scope of the nearest getter, setter,
// method, function, arrow function or file/module
relation FunctionLevelScope(
    scope: ScopeId,
    nearest: ScopeId,
    file: FileId,
    id: AnyId,
)

// Functions are nearest to their bodies
FunctionLevelScope(body, body, file, AnyIdFunc { func }) :-
    Function(func, file, _, _, body, _).

FunctionLevelScope(scope, scope, file, AnyIdFile { file }) :-
    File(file, _, scope).

// Walk the scopes down children
FunctionLevelScope(from, to, file, id) :-
    FunctionLevelScope(from, interum, file, id),
    ChildScope(interum, to, file).

// The `NameInScope` relation gives every name/symbol/ident that's defined for any given scope.
// Names are walked down children scopes, meaning all children have access to the variables of
// their parent scope(s)
//
// ```
// // 'a defines the `foo` symbol
// 'a: { foo }
//  │
//  │ // 'b defines the `bar` symbol and inherits
//  │ // the `foo` symbol
//  └-'b: { foo, bar }
// ```
//
relation NameInScope(
    file: FileId,
    name: Name,
    scope: ScopeId,
    span: Option<Span>,
    declared_in: AnyId,
    implicit: bool,
)

// An index that returns all variables avaliable in a given scope
index Index_VariablesForScope(file: FileId, scope: ScopeId) on NameInScope(file, _, scope, _, _, _)

// An index that returns all variables by the given name in the given scope
index Index_VariableInScope(file: FileId, scope: ScopeId, variable: Name) on NameInScope(file, variable, scope, _, _, _)

// Add implicit globals to every scope
NameInScope(file, name, scope, None, AnyIdGlobal { global }, true) :-
    ImplicitGlobal(global, file, name, _),
    EveryScope(scope, file).

// Import declarations
//
// ```js
// // Scope: { Foo, Bar, .. }
// import { Foo, Bar } from "./somewhere.js";
// // Scope: { Foo, Bar, .. }
// ```
NameInScope(file, name, scope, Some { span }, AnyIdImport { id }, false) :-
    ImportDecl(id, file, clause),
    EveryScope(scope, file),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var free_var = FlatMap(clause.free_variables()),
    Spanned { var name, var span } = free_var.

// Class declarations
//
// Class declarations create a new scope when they're declared,
// so we add the class's name within that scope
//
// ```js
// // Scope: { ... }
// class Baz { }
// // Scope: { Baz, ... }
// ```
//
NameInScope(file, name, scope, Some { span }, AnyIdClass { class }, false) :-
    Class(class, file, Some { Spanned { name, span }}, _, _, scope, _).

// `let` declarations
//
// Let declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// let foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(file, name, scope, Some { span }, AnyIdStmt { stmt }, false) :-
    LetDecl(stmt, file, Some { pat }, _, _),
    Statement(stmt, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// `const` declarations
//
// Const declarations create a new scope when they're declared,
// so we add the variable's name within that scope
//
// ```js
// // Scope: { ... }
// const foo = 10;
// // Scope: { foo, ... }
// ```
//
NameInScope(file, name, scope, Some { span }, AnyIdStmt { stmt }, false) :-
    ConstDecl(stmt, file, Some { pat }, _, _),
    Statement(stmt, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// `var` declarations
//
// Var declarations bubble up to the nearest function-level block
//
// ```js
// // Scope: { ... }
// function foo() {
//     // Scope: { baz, ... }
//     var baz = 10;
//     // Scope: { baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(file, name, nearest, Some { span }, AnyIdStmt { stmt }, false) :-
    VarDecl(stmt, file, Some { pat }, _, _),
    Statement(stmt, file, _, scope, _),
    // Bubble `var` up to the nearest function-level scope
    FunctionLevelScope(nearest, scope, file, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// Function declarations
//
// ```js
// // Scope: { foo, ... }
// function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { foo, ... }
// ```
//
NameInScope(file, name, nearest, Some { span }, AnyIdFunc { func }, false) :-
    Function(func, file, Some { Spanned { name, span }}, scope, _, _),
    // Bubble functions up to the nearest function-level scope
    FunctionLevelScope(nearest, scope, file, _).

// Introduce function arguments within the body of their enclosing function
//
// ```js
// // Scope: { ... }
// function foo(bar, baz) {
//     // Scope: { bar, baz, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(file, name, body, Some { span }, AnyIdFunc { func }, implicit) :-
    FunctionArg(func, file, pat, implicit),
    Function(func, file, _, _, body, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// Introduce closure arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// ((bar, baz) => {
//     // Scope: { bar, baz, ... }
// });
// // Scope: { ... }
// ```
//
// TODO: Can we address Expr/Stmt at the same time instead of seperate rules?
NameInScope(file, name, scope, Some { span }, AnyIdExpr { expr }, false) :-
    ArrowParam(expr, file, pat),
    Arrow(expr, file, Some { Left { body }}),
    Expression(body, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

NameInScope(file, name, scope, Some { span }, AnyIdExpr { expr }, false) :-
    ArrowParam(expr, file, pat),
    Arrow(expr, file, Some { Right { body }}),
    Statement(body, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// Inline function names
//
// Inline functions that are named only have their names added inside their bodies
//
// ```js
// // Scope: { ... }
// let _ = function foo() {
//     // Scope: { foo, ... }
// }
// // Scope: { ... }
// ```
//
NameInScope(file, name, scope, Some { span }, AnyIdExpr { expr }, false) :-
    InlineFunc(expr, file, Some { Spanned { name, span }}, Some { body }),
    Statement(body, file, _, scope, _).

// Introduce inline function arguments within the body of their enclosing closure
//
// ```js
// // Scope: { ... }
// let _ = function(bar, baz) {
//     // Scope: { bar, baz, ... }
// };
// // Scope: { ... }
// ```
//
NameInScope(file, name, scope, Some { span }, AnyIdExpr { expr }, false) :-
    InlineFuncParam(expr, file, pat),
    InlineFunc(expr, file, _, Some { body }),
    Statement(body, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var.

// `catch` statement patterns
NameInScope(file, name, scope, Some { span }, AnyIdStmt { catcher }, false) :-
    Try(stmt, file, _, TryHandler { Some { error }, Some { catcher } }, _),
    Statement(expr, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(error.bound_vars()),
    Spanned { var name, var span } = bound_var.

// Walk variables down scopes
NameInScope(file, name, to, span, declared_in, implicit) :-
    NameInScope(file, name, from, span, declared_in, implicit),
    ChildScope(from, to, file).


relation VariableUsages(file: FileId, name: Name, scope: ScopeId, declared_in: AnyId)
VariableUsages(file, name, scope, declared) :-
    NameInScope(file, name, scope, _, declared, _),
    NameRef(expr, file, name),
    Expression(expr, file, _, scope, _).


output relation UnusedVariables(name: Name, declared: AnyId, span: Span, file: FileId)
UnusedVariables(name, declared, span, file) :-
    NameInScope(file, name, _, Some { span }, declared, false),
    not declared.is_global(),
    not IsExported(file, declared),
    not VariableUsages(file, name, _, declared).

UnusedVariables(name, declared, span, file) :-
    NameInScope(file, name, _, Some { span }, declared @ AnyIdGlobal { global }, false),
    not IsExported(file, declared),
    not VariableUsages(file, name, _, declared).


// The successors of an expression, property accesses or method calls
relation ChainedWith(object: ExprId, property: ExprId, file: FileId)
ChainedWith(object, property, file) :- BracketAccess(_, file, Some { object }, Some { property }).
ChainedWith(object, property, file) :- DotAccess(property, file, Some { object }, _).
ChainedWith(object, property, file) :- ChainedWith(object, interum, file), ChainedWith(interum, property, file).


relation WithinTypeofExpr(type_of: ExprId, expr: ExprId, file: FileId)
// `typeof not_defined`
WithinTypeofExpr(type_of, expr, file) :-
    UnaryOp(type_of, file, Some { UnaryTypeof }, Some { expr }).

// `typeof (not_defined)`
WithinTypeofExpr(type_of, grouped, file) :-
    WithinTypeofExpr(type_of, expr, file),
    Expression(expr, file, ExprGrouping { Some { grouped }}, _, _).

// `typeof (defined, not_defined)`
WithinTypeofExpr(type_of, last, file) :-
    WithinTypeofExpr(type_of, expr, file),
    Expression(expr, file, ExprSequence { sequence }, _, _),
    Some { var last } = sequence.last().


output relation TypeofUndef(whole_expr: ExprId, undefined_expr: ExprId, file: FileId)
TypeofUndef(whole_expr, undefined_expr, file) :-
    NameRef(undefined_expr, file, name),
    Expression(undefined_expr, file, ExprNameRef, scope, span),
    not NameInScope(file, name, scope, _, _, _),
    // Expressions like `typeof not_undefined` are allowed under NoUndef
    // and are instead output through TypeofUndef
    WithinTypeofExpr(whole_expr, undefined_expr, file).


// Variable usages (`let` and `const` predecls or undefined symbols) that don't
// have an accompanying variable in scope are reported
// TODO: Use a levenshtein aggregate to try and correct and/or look in children
//       scopes for a declaration
output relation NoUndef(name: Name, scope: ScopeId, span: Span, file: FileId)
NoUndef(name, scope, span, file) :-
    NameRef(expr, file, name),
    Expression(expr, file, ExprNameRef, scope, span),
    not NameInScope(file, name, scope, _, _, _),
    // Expressions like `typeof not_undefined` are allowed under NoUndef
    // and are instead output through TypeofUndef
    not WithinTypeofExpr(_, expr, file),
    // TODO: This looks wrong
    not ChainedWith(_, expr, file).

// Assignments
NoUndef(name, scope, span, file) :-
    Assign(expr, file, Some { Left { pat }}, _, _),
    Expression(expr, file, _, scope, _),
    // FIXME: Waiting on https://github.com/vmware/differential-datalog/issues/784
    var bound_var = FlatMap(pat.bound_vars()),
    Spanned { var name, var span } = bound_var,
    not NameInScope(file, name, scope, _, _, _).


// TODO: Strip extra info and give fields better names,
//       lint consumers can get needed info via queries
typedef UseBeforeDef = UseBeforeDef {
    name: Name,
    used: ExprId,
    used_in: Span,
    declared: AnyId,
    declared_in: Span,
    file: FileId,
}


// Using variables, classes and functions before they're defined
output relation UseBeforeDef[UseBeforeDef]

// ```js
// foo(bar);
// var bar = 10; // used before def
// ```
UseBeforeDef(name, expr, used_in, declared, declared_in, file) :-
    NameRef(expr, file, name),
    Expression(expr, file, ExprNameRef, used_scope, used_in),
    // Make sure this NameRef isn't the name within a `new` clause,
    // ex. `new Foo(); var Foo;`
    not New(_, file, Some { expr }, _),
    NameInScope(file, name, used_scope, _, declared @ AnyIdStmt { stmt }, _),
    Statement(stmt, file, StmtVarDecl, declared_scope, declared_in),
    declared_scope != used_scope,
    not ChildScope(declared_scope, used_scope, file).

UseBeforeDef(name, expr, used_in, declared, declared_in, file) :-
    New(expr, file, Some { object }, _),
    Expression(expr, file, _, used_scope, used_in),
    NameRef(callee, file, name),
    NameInScope(file, name, used_scope, _, declared @ AnyIdClass { class }, _),
    Class(class, file, Some { Spanned { _, declared_in }}, _, _, decl_scope, _),
    decl_scope != used_scope,
    not ChildScope(decl_scope, used_scope, file).

// TODO: Integrate with directives to ignore functions if the user wants it
UseBeforeDef(name, expr, used_in, declared, declared_in, file) :-
    Call(expr, file, Some { callee }, _),
    Expression(expr, file, _, used_scope, used_in),
    NameRef(callee, file, name),
    NameInScope(file, name, used_scope, _, declared @ AnyIdFunc { func }, _),
    Function(func, file, Some { Spanned { _, declared_in }}, decl_scope, _, _),
    decl_scope != used_scope,
    not ChildScope(decl_scope, used_scope, file).

UseBeforeDef(name, expr, used_in, declared, declared_in, file) :-
    New(expr, file, Some { object }, _),
    Expression(expr, file, _, used_scope, used_in),
    NameRef(object, file, name),
    NameInScope(file, name, used_scope, _, declared @ AnyIdStmt { decl }, _),
    VarDecl(decl, file, _, Some { class }, _),
    ClassExpr(class, file, _),
    Expression(class, file, _, decl_scope, declared_in),
    decl_scope != used_scope,
    not ChildScope(decl_scope, used_scope, file).

UseBeforeDef(name, expr, used_in, declared, declared_in, file) :-
    New(expr, file, Some { object }, _),
    Expression(expr, file, _, used_scope, used_in),
    NameRef(object, file, name),
    NameInScope(file, name, used_scope, _, declared @ AnyIdStmt { decl }, _),
    LetDecl(decl, file, _, Some { class }, _),
    ClassExpr(class, file, _),
    Expression(class, file, _, decl_scope, declared_in),
    decl_scope != used_scope,
    not ChildScope(decl_scope, used_scope, file).

UseBeforeDef(name, expr, used_in, declared, declared_in, file) :-
    New(expr, file, Some { object }, _),
    Expression(expr, file, _, used_scope, used_in),
    NameRef(object, file, name),
    NameInScope(file, name, used_scope, _, declared @ AnyIdStmt { decl }, _),
    ConstDecl(decl, file, _, Some { class }, _),
    ClassExpr(class, file, _),
    Expression(class, file, _, decl_scope, declared_in),
    decl_scope != used_scope,
    not ChildScope(decl_scope, used_scope, file).

UseBeforeDef(name, expr, used_in, AnyIdClass { class }, declared_in, file) :-
    New(expr, file, Some { object }, _),
    Expression(expr, file, _, used_scope, used_in),
    NameRef(object, file, name),
    Class(class, file, Some { Spanned { name, declared_in }}, _, _, declared_scope, _),
    declared_scope != used_scope,
    not ChildScope(declared_scope, used_scope, file).


relation IsExported(file: FileId, id: AnyId)
IsExported(file, AnyIdFunc { id }) :- Function(id, file, _, _, _, true).
IsExported(file, AnyIdClass { id }) :- Class(id, file, _, _, _, _, true).
IsExported(file, AnyIdStmt { id }) :- VarDecl(id, file, _, _, true).
IsExported(file, AnyIdStmt { id }) :- LetDecl(id, file, _, _, true).
IsExported(file, AnyIdStmt { id }) :- ConstDecl(id, file, _, _, true).
IsExported(file, id) :-
    FileExport(file, NamedExport { export_name, export_alias }, export_scope),
    Some { Spanned { var name, _ }} = export_alias.or_else(export_name),
    NameInScope(file, name, export_scope, _, id, false).
