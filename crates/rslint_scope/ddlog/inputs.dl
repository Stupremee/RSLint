// All datalog input relations, derived from the program's ast
import ast

input relation File(
    id: FileId,
    kind: FileKind,
    top_level_scope: ScopeId,
)

input relation FileExport(
    file: FileId,
    export: ExportKind,
    scope: ScopeId,
)

// The input scope relationships, just map parent<-child for one generation
// TODO: Scope spans, make clear if a span is implicit or explicit
input relation InputScope(
    parent: ScopeId,
    child: ScopeId,
    file: FileId,
)
index InputScopeByParent(parent: ScopeId, file: FileId) on InputScope(parent, _, file)
index InputScopeByChild(child: ScopeId, file: FileId) on InputScope(_, child, file)

input relation EveryScope(scope: ScopeId, file: FileId)

// Functions
input relation Function(
    id: FuncId,
    file: FileId,
    name: Option<Spanned<Name>>,
    scope: ScopeId,
    body: ScopeId,
    exported: bool,
)

input relation FunctionArg(
    parent_func: FuncId,
    file: FileId,
    pattern: IPattern,
    implicit: bool,
)

// Class declarations
input relation Class(
    id: ClassId,
    file: FileId,
    name: Option<Spanned<Name>>,
    parent: Option<ExprId>,
    elements: Option<Vec<IClassElement>>,
    scope: ScopeId,
    exported: bool,
)

// Imports
input relation ImportDecl(
    id: ImportId,
    file: FileId,
    clause: ImportClause,
)

// Globals
input relation ImplicitGlobal(
    id: GlobalId,
    file: FileId,
    name: Name,
    privileges: GlobalPriv,
)

// Statements
input relation Statement(
    id: StmtId,
    file: FileId,
    kind: StmtKind,
    scope: ScopeId,
    span: Span,
)

input relation VarDecl(
    stmt_id: StmtId,
    file: FileId,
    pattern: Option<IPattern>,
    value: Option<ExprId>,
    exported: bool,
)

input relation LetDecl(
    stmt_id: StmtId,
    file: FileId,
    pattern: Option<IPattern>,
    value: Option<ExprId>,
    exported: bool,
)

input relation ConstDecl(
    stmt_id: StmtId,
    file: FileId,
    pattern: Option<IPattern>,
    value: Option<ExprId>,
    exported: bool,
)

input relation Return(
    stmt_id: StmtId,
    file: FileId,
    value: Option<ExprId>,
)

input relation If(
    stmt_id: StmtId,
    file: FileId,
    cond: Option<ExprId>,
    if_body: Option<StmtId>,
    else_body: Option<StmtId>,
)

input relation Break(
    stmt_id: StmtId,
    file: FileId,
    label: Option<Name>,
)

input relation DoWhile(
    stmt_id: StmtId,
    file: FileId,
    body: Option<StmtId>,
    cond: Option<ExprId>,
)

input relation While(
    stmt_id: StmtId,
    file: FileId,
    cond: Option<ExprId>,
    body: Option<StmtId>,
)

input relation For(
    stmt_id: StmtId,
    file: FileId,
    init: Option<ForInit>,
    test: Option<ExprId>,
    update: Option<ExprId>,
    body: Option<StmtId>,
)

input relation ForIn(
    stmt_id: StmtId,
    file: FileId,
    elem: Option<ForInit>,
    collection: Option<ExprId>,
    body: Option<StmtId>,
)

input relation Continue(
    stmt_id: StmtId,
    file: FileId,
    label: Option<Name>,
)

input relation With(
    stmt_id: StmtId,
    file: FileId,
    cond: Option<ExprId>,
    body: Option<StmtId>,
)

input relation Label(
    stmt_id: StmtId,
    file: FileId,
    name: Option<Spanned<Name>>,
    body: Option<StmtId>,
)

// Switch statements & cases
input relation Switch(
    stmt_id: StmtId,
    file: FileId,
    test: Option<ExprId>,
)

// TODO: Flatten the cases?
input relation SwitchCase(
    stmt_id: StmtId,
    file: FileId,
    case: SwitchClause,
    body: Option<StmtId>,
)

input relation Throw(
    stmt_id: StmtId,
    file: FileId,
    exception: Option<ExprId>,
)

input relation Try(
    stmt_id: StmtId,
    file: FileId,
    body: Option<StmtId>,
    handler: TryHandler,
    finalizer: Option<StmtId>,
)

// Expressions
typedef Expression = Expression {
    id: ExprId,
    file: FileId,
    kind: ExprKind,
    scope: ScopeId,
    span: Span,
}
input relation Expression[Expression]

index ExpressionById(id: ExprId, file: FileId) on Expression[Expression { .id = id, .file = file }]

index ExpressionBySpan(span: Span, file: FileId) on Expression[Expression { .span = span, .file = file }]

input relation ExprNumber(
    expr_id: ExprId,
    file: FileId,
    value: double,
)

input relation ExprBigInt(
    expr_id: ExprId,
    file: FileId,
    value: bigint,
)

input relation ExprString(
    expr_id: ExprId,
    file: FileId,
    value: istring,
)

input relation ExprBool(
    expr_id: ExprId,
    file: FileId,
    value: bool,
)

input relation NameRef(
    expr_id: ExprId,
    file: FileId,
    value: Name,
)

input relation Yield(
    expr_id: ExprId,
    file: FileId,
    value: Option<ExprId>,
)

input relation Await(
    expr_id: ExprId,
    file: FileId,
    value: Option<ExprId>,
)

input relation Arrow(
    expr_id: ExprId,
    file: FileId,
    body: Option<Either<ExprId, StmtId>>,
)

// TODO: Inline this into Arrow?
input relation ArrowParam(
    expr_id: ExprId,
    file: FileId,
    param: IPattern,
)

input relation UnaryOp(
    expr_id: ExprId,
    file: FileId,
    op: Option<UnaryOperand>,
    expr: Option<ExprId>,
)

input relation BinOp(
    expr_id: ExprId,
    file: FileId,
    op: Option<BinOperand>,
    lhs: Option<ExprId>,
    rhs: Option<ExprId>,
)

input relation Ternary(
    expr_id: ExprId,
    file: FileId,
    test: Option<ExprId>,
    true_val: Option<ExprId>,
    false_val: Option<ExprId>,
)

input relation Template(
    expr_id: ExprId,
    file: FileId,
    tag: Option<ExprId>,
    elements: Vec<ExprId>,
)

input relation Array(
    expr_id: ExprId,
    file: FileId,
    elements: Vec<ArrayElement>,
)

input relation Property(
    expr_id: ExprId,
    file: FileId,
    key: Option<PropertyKey>,
    val: Option<PropertyVal>,
)

input relation BracketAccess(
    expr_id: ExprId,
    file: FileId,
    object: Option<ExprId>,
    prop: Option<ExprId>,
)

input relation DotAccess(
    expr_id: ExprId,
    file: FileId,
    object: Option<ExprId>,
    prop: Option<Spanned<Name>>,
)

input relation New(
    expr_id: ExprId,
    file: FileId,
    object: Option<ExprId>,
    args: Option<Vec<ExprId>>,
)

input relation Call(
    expr_id: ExprId,
    file: FileId,
    callee: Option<ExprId>,
    args: Option<Vec<ExprId>>,
)

input relation Assign(
    expr_id: ExprId,
    file: FileId,
    lhs: Option<Either<IPattern, ExprId>>,
    rhs: Option<ExprId>,
    op: Option<AssignOperand>,
)

input relation InlineFunc(
    expr_id: ExprId,
    file: FileId,
    name: Option<Spanned<Name>>,
    body: Option<StmtId>,
)

// TODO: Inline this?
input relation InlineFuncParam(
    expr_id: ExprId,
    file: FileId,
    param: IPattern,
)

input relation ClassExpr(
    expr_id: ExprId,
    file: FileId,
    elements: Option<Vec<IClassElement>>,
)
